<!doctype html>
<html>
<head>
	<meta charset="utf-8">
	<title>Focused MDS</title>
	<style>
	body {
		background-color: white;
	}
	</style>
	<script src="FocusedMDS/inst/htmlwidgets/lib/optimize_js/optimize_for_javascript.js" type="text/javascript"></script>
	<script src="https://d3js.org/d3.v4.min.js"></script>
	<script src="focusedMDS_showcase.js" type="text/javascript"></script>	
	
		
</head>

<h1>Focused Multidimensional Scaling</h1>

<p>Focused multidimensional scaling (focusedMDS) is a tool for visualizing the multidimensional data contained within a data matrix. Visualization is a key tool in understanding real relationships among data within a dataset, and current static tools for visualization of data from distance matrices via multidimensional scaling can be misleading. FocusedMDS better represents the real relationships among data in a distance matrix.</p>

<h3>Iris data set plot</h3>
<div id="main"> </div>

<p>In this graph, you can choose a particular data point (the focus), around which all other points are plotted in their exact distances to the focus (as given in the data matrix). The distances of the non-focus points are plotted as close to their ideal distances as possible. This allows you to move the graph to different perspectives, investigating clusters.</p>

<img src="Fig1.png" alt="Figure1" style="height:300px; width:300px">
<img src="Fig2.png" alt="Figure2" style="height:300px; width:300px">


<script>

// Initializing values
var old_result = {};
var result = {};
var scale = {};
var element_ids = {};
var focus_point = "__none__";
var sliderPosition = null;
var circles = 12;
var size = 400
var tol = 0.01

// Make initial graph with all labels and colors

var color_object = {};
for(var i=0; i < colors.length; i++) {
	 color_object[ids[i]] = colors[i]
};

focus_point = ids[0]
result = focused_mds(distances, ids, focus_point, tol)

// Find max distance in dist for scaling factor functions
var maxDistance = [];

for(var i=0; i< distances.length; i++) {
	 for(j=0; j< distances.length; j++){
	 if( maxDistance < distances[i][j]){
	 	maxDistance = distances[i][j]
	 }
 }
};
// Create scaling factors
scale = d3.scaleLinear()
         .domain([-1*maxDistance, maxDistance])
         .range([0, size]);

// Create polar coordinate gridline radii
var gridlines_rs = [];
for(var i=1; i != circles; i++) { gridlines_rs.push((i/Math.round((circles - 2) / 2 )) * size / 2) }	

// Create svg and append to a div
	  
var chart_container = d3.select("div")
 .append('div')
    .attr('id', 'chart_container')

var chart = chart_container.append('svg:svg')
	 	 .attr('width', size )
	 	 .attr('height', size )
	 	 .attr('class', 'chart')
	 	 .attr('id', 'chart_svg')
	  
var g = chart.append('g')
	     .attr('width', size)
	     .attr('height', size)
	     .attr('class', 'main');

// Create div for sidebar stuff and append to chart_container

var chart_inset = d3.select("div")
  .append('div')
  .style('position', 'absolute')
  .style('top', '0')
  .style('left', '0')
     .attr('id', 'chart_inset')
     .attr('height', 61)
     .attr('width', 140)

var chart_background = chart_inset.append('svg')
  .style('position', 'relative')
  .style('z-index', 1)
  .style('top', '0')
  .style('left', '0')
     .attr('height', 61)
     .attr('width', 140)

chart_background.append('rect')
  .attr('fill', 'white')
  .attr('height', 61)
  .attr('width', 140)

var button_div = chart_inset.append('div')
  .style('text-align', 'left')
  .style('position', 'absolute')
  .style('z-index', 2)
  .style('top', 0)
  .style('left', 0)

var button = button_div.append('input')
     .attr('type', 'checkbox')
     .property('checked', false)

chart_inset.select('input').on('change', function(d){ 
 if (button.property('checked') == true) { 
	 g.selectAll('text')
	     .style('visibility', 'visible')
 } else { 
	 g.selectAll('text')
		 .style('visibility', 'hidden')
 }
})

var text = button_div.append('text')
 .text(' Show all labels')
 .style('font-family', 'Georgia, serif')
 .style('font-size', '12px')


var slider_div = chart_inset.append('div')
 .style('text-align', 'center')
  .style('position', 'absolute')
  .style('z-index', 2)
  .style('top', '20px')
  .style('left', 0)

slider_div.append('text')
 .text('Circle size:')
 .style('font-family', 'Georgia, serif')
 .style('font-size', '12px')


var sliderContainer = slider_div.append('svg')
 .attr('height',20)
 .attr('width', 140)

var slider = sliderContainer.append('g')
 .attr('class', 'slider')
 .attr('width', 150)

slider.append('line')
       .attr('class', 'track')
       .attr('y1', 10)
       .attr('y2', 10)
       .attr('x1', 10)
       .attr('x2', 130)
       .style('stroke-linecap', 'round')
       .style('stroke-opacity', 0.3)
       .style('stroke-width', '8px')
       .style('stroke', '#000')
 .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
       .attr('class', 'track-inset')
       .style('stroke-linecap', 'round')
       .style('stroke', '#ddd')
       .style('stroke-width', '3px')
 .select(function() { return this.parentNode.appendChild(this.cloneNode(true)); })
       .attr('class', 'track-overlay')
       .style('stroke-linecap','round')
       .style('pointer-events', 'stroke')
       .style('stroke-width', '15px')
       .style('cursor', 'crosshair')
       .call(d3.drag()
               .on('start.interrupt', function() { slider.interrupt(); })
		       .on('start.drag', function() { sizeAdjust(d3.event.x); }))

var handle = slider.insert('circle', '.track-overlay')
       .attr('class','handle')
       .attr('r', 4)
       .attr('cx', 65)
       .attr('cy', 10)
       .style('fill', '#fff')
       .style('stroke', '#000')
       .style('stroke-opacity', '0.5')
       .style('stroke-width', '1.25px')	

function sizeAdjust(input) {
 if(input < 10){
 	handle.attr('cx', 10)
 } else if(input > 130){
 	handle.attr('cx', 130)
 } else {
 	handle.attr('cx', input)
 };
 
 g.selectAll('circle')
     .attr('r', 0.2 * size/20 * input/65 );
 
 sliderPosition = input;
}	 
			 
// Create background bars
g.selectAll("ellipse")
 .data(gridlines_rs)
 .enter().append("ellipse")
	 .attr("class", "polar_gridlines")
     .attr("cx", function() {return (result[focus_point]['x'] + size/2 ); })
     .attr("cy", function() {return (result[focus_point]['y'] + size/2 ); })
	 .attr("rx", function(d) { return d; })
 	 .attr("ry", function(d) { return d; })
	 .attr("fill", "none")
	 .attr("stroke","gray")

// Create scatterplot circles with clickable reordering
g.selectAll("circle")
    .data(ids)
    .enter().append("circle")
	       .attr("class", "data_points")
		   .attr("cx", function(d,i) { return scale(result[d]['x']); })
		   .attr("cy", function(d,i) { return scale(result[d]['y']); })
		   .attr("r", 0.2 * size/20)
           .attr("fill", function(d,i) { return color_object[d]})
		   .attr("stroke", function(d,i) { if(Object.keys(result).indexOf(d) == 0) { return "red"}})  
		   .on( "dblclick", function(d,i) {
			   // save phis from previous result for arc transition
			   old_result = {};
			   for(var i=0; i< Object.keys(result).length; i++){
				   old_result[Object.keys(result)[i]] = {
					   phi: result[Object.keys(result)[i]].phi,
					   r: result[Object.keys(result)[i]].r
				   }
		       }
		
			   // update result object by rerunning focused_mds
			   result = focused_mds(distances, ids, d, tol)
		       focus_point = d
		       
			   // update all circles
			   g.selectAll("circle")
			       .data(ids)
			       .transition()
			       .duration(3000)
			       .attrTween("cx", function(d,i) {
					   var phiTween = d3.scaleLinear().range( [old_result[d].phi, result[d].phi] )
					   var rTween = d3.scaleLinear().range( [old_result[d].r, result[d].r] )
					   return function(t) { return scale( rTween(t) * cos( phiTween(t) ) )}
				   })
				   .attrTween("cy", function(d,i) {
					   var phiTween = d3.scaleLinear().range( [old_result[d].phi, result[d].phi] )
					   var rTween = d3.scaleLinear().range( [old_result[d].r, result[d].r] )
					   return function(t) { return scale( rTween(t) * sin( phiTween(t) ) )}
				   })
				   .attr("fill", function(d,i) { return color_object[d]})
			   	   .attr("stroke", function(d,i) { if(Object.keys(result).indexOf(d) == 0) { return "red"}})

			   // update text locations
			   g.selectAll("text")
			   	   .data(ids)
			       .transition()
				   .duration(3000)
			       .attrTween("x", function(d,i) {
					   var phiTween = d3.scaleLinear().range( [old_result[d].phi, result[d].phi] )
					   var rTween = d3.scaleLinear().range( [old_result[d].r, result[d].r] )
					   return function(t) { return scale( rTween(t) * cos( phiTween(t) ) ) + size/100}
				   })
				   .attrTween("y", function(d,i) {
					   var phiTween = d3.scaleLinear().range( [old_result[d].phi, result[d].phi] )
					   var rTween = d3.scaleLinear().range( [old_result[d].r, result[d].r] )
					   return function(t) { return scale( rTween(t) * sin( phiTween(t) ) )}
				   })
				   .text( function (d) {return d })

		 	 })

			 .on("mouseover", function(d){
  			     d3.select("text#X"+d)	 	 
				     .style("visibility","visible")
		     })
	         .on("mouseout", function(d){
			 if( button.property('checked') == false ){
 			         d3.select("text#X"+d)
			  	         .style("visibility","hidden")
			 } 
		     })
		     ;
// Add svg text element to g
var text = g.selectAll("text")
            .data(ids)
            .enter()
            .append("text")
		    .attr("id",function(d){return "X"+d;})
		    .attr("class","textLabels")

// Create text labels	
var textLabels = text
  	  		     .attr('x', function(d,i) {return scale(result[d]['x']) + size/100; })
				 .attr('y', function(d,i) {return scale(result[d]['y']); })
				 .text( function (d) {return d })
				 .attr("font-family", "sans-serif")
				 .attr("font-size", "12px")
				 .attr("fill", "black")
				 .style("visibility","hidden") 
</script>

</html>